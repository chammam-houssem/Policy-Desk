<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-QMG7PT3J0Z"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-QMG7PT3J0Z');
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Coal Power Dataset (2005–2025) — Exploratory Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="icon" href="icon.svg" type="image/svg+xml">
  <style>
    :root {
      --card-bg: #ffffff;
      --card-border: #e9ecef;
      --ink: #1f2937;
      --muted: #6b7280;
      --accent: #0f4c81;
      --accent-soft: #edf2f7;
    }

    body {
      background-color: #f7f8fb;
      color: var(--ink);
    }

    .page-wrap {
      padding: 32px 0 60px;
    }

    .page-title {
      font-family: 'Roboto Serif', serif;
      font-weight: 600;
      letter-spacing: 0.01em;
      color: #102a43;
    }

    .page-subtitle {
      color: var(--muted);
      max-width: 760px;
    }

    .method-note {
      background: var(--accent-soft);
      border-left: 4px solid var(--accent);
      padding: 10px 14px;
      color: #1f3a5f;
      font-size: 14px;
      border-radius: 6px;
    }

    .card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 18px 20px;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.06);
    }

    .control-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
    }

    label {
      font-size: 13px;
      font-weight: 600;
      color: #1f2937;
      display: block;
      margin-bottom: 6px;
    }

    select,
    input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      background: #fff;
      font-size: 14px;
      color: #111827;
    }

    .toggle-group {
      display: flex;
      gap: 8px;
      background: #f1f5f9;
      border-radius: 10px;
      padding: 4px;
    }

    .toggle-btn {
      flex: 1;
      border: none;
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      color: #475569;
      background: transparent;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .toggle-btn.active {
      background: #102a43;
      color: #fff;
      box-shadow: 0 6px 16px rgba(16, 42, 67, 0.2);
    }

    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 14px;
    }

    .kpi-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #6b7280;
    }

    .kpi-value {
      font-size: 24px;
      font-weight: 700;
      color: #111827;
      margin-top: 6px;
    }

    .kpi-sub {
      font-size: 12px;
      color: #6b7280;
      margin-top: 4px;
    }

    .chart-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 18px;
    }

    .chart-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 4px;
      color: #1f2937;
    }

    .chart-subtitle {
      font-size: 13px;
      color: #6b7280;
      margin-bottom: 12px;
    }

    .chart-wrapper {
      height: 320px;
    }

    .chart-note {
      font-size: 12px;
      color: #6b7280;
      margin-top: 8px;
    }

    .hidden {
      display: none !important;
    }

    .table-wrap {
      overflow-x: auto;
      border: 1px solid var(--card-border);
      border-radius: 10px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    thead {
      background: #f8fafc;
      text-align: left;
    }

    th,
    td {
      padding: 10px 12px;
      border-bottom: 1px solid #e5e7eb;
      white-space: nowrap;
    }

    .download-btn {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 8px 14px;
      border-radius: 8px;
      border: none;
      background: #102a43;
      color: #fff;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
    }

    .error-panel {
      background: #fff1f2;
      border: 1px solid #fecdd3;
      color: #9f1239;
      padding: 14px 16px;
      border-radius: 10px;
      font-size: 13px;
      margin-bottom: 20px;
    }

    .quality-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 10px;
      font-size: 13px;
      color: #1f2937;
    }

    .quality-item {
      padding: 10px 12px;
      border: 1px dashed #cbd5f5;
      border-radius: 8px;
      background: #f8fafc;
    }

    .tab-nav a[href$="data.html"] {
      display: inline-flex !important;
    }

    @media (max-width: 768px) {
      .chart-wrapper {
        height: 260px;
      }
    }
  </style>
</head>
<body class="antialiased">
  <nav class="tab-navigation">
    <div class="container">
      <div class="tab-nav">
        <a href="index.html" class="nav-btn tab-btn">Overview</a>
        <a href="data.html" class="nav-btn tab-btn">Data Projects</a>
        <a href="blog.html" class="nav-btn tab-btn">Blog</a>
        <a href="coal-eda.html" class="nav-btn tab-btn active">Coal EDA</a>
      </div>
    </div>
  </nav>

  <main class="page-wrap">
    <div class="container">
      <header class="mb-8">
        <h1 class="text-3xl md:text-4xl page-title">Coal Power Dataset (2005–2025) — Exploratory Dashboard</h1>
        <p class="mt-3 page-subtitle">A pre-analysis scan of coverage, missingness, and large-scale patterns in the coal and fossil fuel panel dataset.</p>
        <div class="method-note mt-4">This page checks coverage, missingness, and basic patterns. It does not infer causality.</div>
      </header>

      <div id="parseError" class="error-panel hidden"></div>

      <section class="card mb-8">
        <h2 class="text-lg font-semibold mb-4">Filters</h2>
        <div class="control-grid">
          <div>
            <label for="metricSelect">Metric</label>
            <select id="metricSelect"></select>
          </div>

          <div>
            <label>Year Mode</label>
            <div class="toggle-group">
              <button class="toggle-btn active" data-mode="single" type="button">Single-year</button>
              <button class="toggle-btn" data-mode="range" type="button">Range</button>
            </div>
          </div>

          <div id="singleYearWrap">
            <label for="singleYearSelect">Year</label>
            <select id="singleYearSelect"></select>
          </div>

          <div id="rangeYearWrap" class="hidden">
            <label for="startYearSelect">Start year</label>
            <select id="startYearSelect"></select>
          </div>

          <div id="rangeYearWrapEnd" class="hidden">
            <label for="endYearSelect">End year</label>
            <select id="endYearSelect"></select>
          </div>

          <div>
            <label for="countryInput">Country (search)</label>
            <input id="countryInput" list="countryList" type="text" placeholder="All countries" />
            <datalist id="countryList"></datalist>
            <p class="text-xs text-gray-500 mt-2">Country filter affects KPIs, missingness, preview, and profile.</p>
          </div>
        </div>
      </section>

      <section class="kpi-grid mb-8">
        <div class="card">
          <div class="kpi-label">Countries in selection</div>
          <div id="kpiCountries" class="kpi-value">—</div>
          <div class="kpi-sub" id="kpiCountriesSub"></div>
        </div>
        <div class="card">
          <div class="kpi-label">Rows in selection</div>
          <div id="kpiRows" class="kpi-value">—</div>
          <div class="kpi-sub" id="kpiRowsSub"></div>
        </div>
        <div class="card">
          <div class="kpi-label">Missingness (metric)</div>
          <div id="kpiMissing" class="kpi-value">—</div>
          <div class="kpi-sub" id="kpiMissingSub"></div>
        </div>
        <div class="card">
          <div class="kpi-label">Latest year with data</div>
          <div id="kpiLatest" class="kpi-value">—</div>
          <div class="kpi-sub" id="kpiLatestSub"></div>
        </div>
        <div class="card">
          <div class="kpi-label">Median value</div>
          <div id="kpiMedian" class="kpi-value">—</div>
          <div class="kpi-sub" id="kpiMedianSub"></div>
        </div>
      </section>

      <section class="chart-grid mb-8">
        <div class="card">
          <div class="chart-title">Global trend</div>
          <div class="chart-subtitle">Total (or weighted mean) by year for the selected metric.</div>
          <div class="chart-wrapper">
            <canvas id="globalTrendChart"></canvas>
          </div>
          <div id="globalTrendNote" class="chart-note"></div>
        </div>

        <div class="card">
          <div class="chart-title">Coverage over time</div>
          <div class="chart-subtitle">Countries with non-missing values by year.</div>
          <div class="chart-wrapper">
            <canvas id="coverageChart"></canvas>
          </div>
        </div>

        <div class="card">
          <div class="chart-title">Top countries</div>
          <div class="chart-subtitle">Top 15 by selected metric (year or range average).</div>
          <div class="chart-wrapper">
            <canvas id="topCountriesChart"></canvas>
          </div>
        </div>

        <div class="card">
          <div class="chart-title">Missingness by variable</div>
          <div class="chart-subtitle">Share of missing values in the current filter window.</div>
          <div class="chart-wrapper">
            <canvas id="missingnessChart"></canvas>
          </div>
        </div>
      </section>

      <section id="countryProfileSection" class="card mb-8 hidden">
        <div class="chart-title">Country profile</div>
        <div class="chart-subtitle">Time series for the selected country (with a comparison series when relevant).</div>
        <div class="chart-wrapper">
          <canvas id="countryProfileChart"></canvas>
        </div>
      </section>

      <section class="card mb-8">
        <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-4 mb-4">
          <div>
            <div class="chart-title">Data preview</div>
            <div class="chart-subtitle">First 25 rows after filters.</div>
          </div>
          <button id="downloadBtn" class="download-btn" type="button">
            <i class="fas fa-download"></i>
            Download filtered CSV
          </button>
        </div>
        <div class="table-wrap">
          <table>
            <thead>
              <tr id="previewHeader"></tr>
            </thead>
            <tbody id="previewBody"></tbody>
          </table>
        </div>
      </section>

      <section class="card">
        <div class="chart-title">Data quality checks</div>
        <div class="chart-subtitle">Automated scan of core structural issues.</div>
        <div id="qualityList" class="quality-list"></div>
      </section>
    </div>
  </main>

  <script src="script.js"></script>
  <script>
    const CSV_PATH = './data/energy-data-coal-countries-2005-2025.csv';

    const METRICS = [
      { key: 'coal_electricity', label: 'Coal electricity', unit: 'TWh' },
      { key: 'coal_share_elec', label: 'Coal share of electricity', unit: '%' },
      { key: 'coal_consumption', label: 'Coal consumption', unit: 'TWh' },
      { key: 'coal_production', label: 'Coal production', unit: 'TWh' },
      { key: 'fossil_electricity', label: 'Fossil electricity', unit: 'TWh' },
      { key: 'fossil_share_elec', label: 'Fossil share of electricity', unit: '%' },
      { key: 'greenhouse_gas_emissions', label: 'Greenhouse gas emissions', unit: 'Mt CO2e' },
      { key: 'gdp', label: 'GDP', unit: 'intl-$ 2011' },
      { key: 'population', label: 'Population', unit: 'people' }
    ];

    const KEY_VARIABLES = [
      'coal_electricity',
      'coal_share_elec',
      'coal_consumption',
      'coal_production',
      'fossil_electricity',
      'fossil_share_elec',
      'fossil_fuel_consumption',
      'greenhouse_gas_emissions',
      'population',
      'gdp'
    ];

    const state = {
      metricKey: 'coal_electricity',
      yearMode: 'single',
      year: null,
      startYear: null,
      endYear: null,
      selectedCountry: null,
      selectedCountryDisplay: ''
    };

    let cachedRows = [];
    let yearsList = [];
    let countryIndex = new Map();

    const elements = {
      metricSelect: document.getElementById('metricSelect'),
      singleYearWrap: document.getElementById('singleYearWrap'),
      rangeYearWrap: document.getElementById('rangeYearWrap'),
      rangeYearWrapEnd: document.getElementById('rangeYearWrapEnd'),
      singleYearSelect: document.getElementById('singleYearSelect'),
      startYearSelect: document.getElementById('startYearSelect'),
      endYearSelect: document.getElementById('endYearSelect'),
      countryInput: document.getElementById('countryInput'),
      countryList: document.getElementById('countryList'),
      parseError: document.getElementById('parseError'),
      kpiCountries: document.getElementById('kpiCountries'),
      kpiCountriesSub: document.getElementById('kpiCountriesSub'),
      kpiRows: document.getElementById('kpiRows'),
      kpiRowsSub: document.getElementById('kpiRowsSub'),
      kpiMissing: document.getElementById('kpiMissing'),
      kpiMissingSub: document.getElementById('kpiMissingSub'),
      kpiLatest: document.getElementById('kpiLatest'),
      kpiLatestSub: document.getElementById('kpiLatestSub'),
      kpiMedian: document.getElementById('kpiMedian'),
      kpiMedianSub: document.getElementById('kpiMedianSub'),
      globalTrendNote: document.getElementById('globalTrendNote'),
      previewHeader: document.getElementById('previewHeader'),
      previewBody: document.getElementById('previewBody'),
      downloadBtn: document.getElementById('downloadBtn'),
      qualityList: document.getElementById('qualityList'),
      countryProfileSection: document.getElementById('countryProfileSection')
    };

    function cleanValue(value) {
      if (value === null || value === undefined) return null;
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (trimmed === '' || trimmed.toUpperCase() === 'NA') return null;
        return trimmed;
      }
      return value;
    }

    function coerceNumber(value) {
      const cleaned = cleanValue(value);
      if (cleaned === null) return null;
      const numberValue = Number(cleaned);
      return Number.isFinite(numberValue) ? numberValue : null;
    }

    function coerceYear(value) {
      const cleaned = cleanValue(value);
      if (cleaned === null) return null;
      const yearValue = parseInt(cleaned, 10);
      return Number.isFinite(yearValue) ? yearValue : null;
    }

    function isShareMetric(metricKey) {
      return metricKey.includes('share');
    }

    function formatNumber(value, options = {}) {
      if (value === null || value === undefined || Number.isNaN(value)) return '—';
      return new Intl.NumberFormat('en-US', options).format(value);
    }

    function formatMetricValue(value, metricKey) {
      if (value === null || value === undefined || Number.isNaN(value)) return '—';
      if (isShareMetric(metricKey)) {
        return `${formatNumber(value, { maximumFractionDigits: 2 })}%`;
      }
      return formatNumber(value, { maximumFractionDigits: 2 });
    }

    function getMetricMeta(metricKey) {
      return METRICS.find(metric => metric.key === metricKey) || { label: metricKey, unit: '' };
    }

    function setMetricOptions() {
      elements.metricSelect.innerHTML = '';
      METRICS.forEach(metric => {
        const option = document.createElement('option');
        option.value = metric.key;
        option.textContent = `${metric.label} (${metric.unit})`;
        elements.metricSelect.appendChild(option);
      });
      elements.metricSelect.value = state.metricKey;
    }

    function setYearOptions() {
      const buildOptions = (selectEl) => {
        selectEl.innerHTML = '';
        yearsList.forEach(year => {
          const option = document.createElement('option');
          option.value = year;
          option.textContent = year;
          selectEl.appendChild(option);
        });
      };

      buildOptions(elements.singleYearSelect);
      buildOptions(elements.startYearSelect);
      buildOptions(elements.endYearSelect);

      if (yearsList.length > 0) {
        state.year = state.year || yearsList[yearsList.length - 1];
        state.startYear = state.startYear || yearsList[0];
        state.endYear = state.endYear || yearsList[yearsList.length - 1];

        elements.singleYearSelect.value = state.year;
        elements.startYearSelect.value = state.startYear;
        elements.endYearSelect.value = state.endYear;
      }
    }

    function setCountryOptions() {
      elements.countryList.innerHTML = '';
      countryIndex.forEach(entry => {
        const option = document.createElement('option');
        option.value = entry.display;
        elements.countryList.appendChild(option);
      });
    }

    function getYearBounds() {
      if (state.yearMode === 'single') {
        return { start: state.year, end: state.year };
      }
      return { start: state.startYear, end: state.endYear };
    }

    function inYearRange(year) {
      const bounds = getYearBounds();
      if (year === null || bounds.start === null || bounds.end === null) return false;
      return year >= bounds.start && year <= bounds.end;
    }

    function getCountryKey(row) {
      const iso = cleanValue(row.iso_code);
      const country = cleanValue(row.country);
      return iso || country || null;
    }

    function getCountryLabel(row) {
      return cleanValue(row.country) || cleanValue(row.iso_code) || 'Unknown';
    }

    function resolveCountry(inputValue) {
      if (!inputValue) return null;
      const trimmed = inputValue.trim();
      if (!trimmed) return null;
      const lower = trimmed.toLowerCase();
      if (countryIndex.has(trimmed)) return countryIndex.get(trimmed);

      for (const entry of countryIndex.values()) {
        if (entry.country && entry.country.toLowerCase() === lower) return entry;
        if (entry.iso && entry.iso.toLowerCase() === lower) return entry;
      }
      return null;
    }

    function applyCountryFilter(rows) {
      if (!state.selectedCountry) return rows;
      return rows.filter(row => {
        const country = cleanValue(row.country);
        const iso = cleanValue(row.iso_code);
        return (
          (state.selectedCountry.iso && iso === state.selectedCountry.iso) ||
          (state.selectedCountry.country && country === state.selectedCountry.country)
        );
      });
    }

    function filterRows(rows, { applyCountry = true } = {}) {
      const filtered = rows.filter(row => {
        const year = coerceYear(row.year);
        if (!inYearRange(year)) return false;
        return true;
      });
      return applyCountry ? applyCountryFilter(filtered) : filtered;
    }

    function updateToggleButtons() {
      document.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === state.yearMode);
      });
      if (state.yearMode === 'single') {
        elements.singleYearWrap.classList.remove('hidden');
        elements.rangeYearWrap.classList.add('hidden');
        elements.rangeYearWrapEnd.classList.add('hidden');
      } else {
        elements.singleYearWrap.classList.add('hidden');
        elements.rangeYearWrap.classList.remove('hidden');
        elements.rangeYearWrapEnd.classList.remove('hidden');
      }
    }

    function median(values) {
      if (!values.length) return null;
      const sorted = [...values].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 0) {
        return (sorted[mid - 1] + sorted[mid]) / 2;
      }
      return sorted[mid];
    }

    function updateKPIs() {
      const filtered = filterRows(cachedRows, { applyCountry: true });
      const filteredGlobal = filterRows(cachedRows, { applyCountry: false });
      const metricKey = state.metricKey;

      const countrySet = new Set(filtered.map(row => getCountryKey(row)).filter(Boolean));
      elements.kpiCountries.textContent = formatNumber(countrySet.size, { maximumFractionDigits: 0 });
      elements.kpiCountriesSub.textContent = state.selectedCountry ? 'Filtered by country' : 'All countries in selection';

      elements.kpiRows.textContent = formatNumber(filtered.length, { maximumFractionDigits: 0 });
      elements.kpiRowsSub.textContent = `Year mode: ${state.yearMode}`;

      const missingCount = filtered.reduce((acc, row) => {
        const value = coerceNumber(row[metricKey]);
        return acc + (value === null ? 1 : 0);
      }, 0);
      const missingPct = filtered.length ? (missingCount / filtered.length) * 100 : 0;
      elements.kpiMissing.textContent = `${formatNumber(missingPct, { maximumFractionDigits: 1 })}%`;
      elements.kpiMissingSub.textContent = `${formatNumber(missingCount, { maximumFractionDigits: 0 })} rows missing`;

      const latestGlobal = filteredGlobal.reduce((maxYear, row) => {
        const year = coerceYear(row.year);
        const value = coerceNumber(row[metricKey]);
        if (year !== null && value !== null) {
          return year > maxYear ? year : maxYear;
        }
        return maxYear;
      }, -Infinity);
      let latestCountry = null;
      if (state.selectedCountry) {
        latestCountry = filtered.reduce((maxYear, row) => {
          const year = coerceYear(row.year);
          const value = coerceNumber(row[metricKey]);
          if (year !== null && value !== null) {
            return year > maxYear ? year : maxYear;
          }
          return maxYear;
        }, -Infinity);
        if (!Number.isFinite(latestCountry)) latestCountry = null;
      }

      elements.kpiLatest.textContent = Number.isFinite(latestGlobal) ? latestGlobal : '—';
      elements.kpiLatestSub.textContent = latestCountry ? `Selected country: ${latestCountry}` : 'Global within selection';

      let medianValue = null;
      if (state.yearMode === 'single') {
        const values = [];
        const seen = new Set();
        filtered.forEach(row => {
          const key = getCountryKey(row);
          if (!key || seen.has(key)) return;
          const value = coerceNumber(row[metricKey]);
          if (value !== null) {
            values.push(value);
            seen.add(key);
          }
        });
        medianValue = median(values);
      } else {
        const map = new Map();
        filtered.forEach(row => {
          const key = getCountryKey(row);
          const value = coerceNumber(row[metricKey]);
          if (!key || value === null) return;
          if (!map.has(key)) map.set(key, { sum: 0, count: 0 });
          const entry = map.get(key);
          entry.sum += value;
          entry.count += 1;
        });
        const averages = Array.from(map.values())
          .filter(entry => entry.count > 0)
          .map(entry => entry.sum / entry.count);
        medianValue = median(averages);
      }

      elements.kpiMedian.textContent = formatMetricValue(medianValue, metricKey);
      elements.kpiMedianSub.textContent = state.yearMode === 'single' ? 'Median across countries' : 'Median of country averages';
    }

    function updatePreviewTable() {
      const filtered = filterRows(cachedRows, { applyCountry: true });
      const metricMeta = getMetricMeta(state.metricKey);
      const headerCells = [
        'country',
        'iso_code',
        'year',
        `${state.metricKey} (${metricMeta.unit})`,
        'population',
        'gdp'
      ];

      elements.previewHeader.innerHTML = '';
      headerCells.forEach(label => {
        const th = document.createElement('th');
        th.textContent = label;
        elements.previewHeader.appendChild(th);
      });

      elements.previewBody.innerHTML = '';
      const previewRows = filtered.slice(0, 25);
      previewRows.forEach(row => {
        const tr = document.createElement('tr');
        const cells = [
          cleanValue(row.country) || '—',
          cleanValue(row.iso_code) || '—',
          coerceYear(row.year) || '—',
          formatMetricValue(coerceNumber(row[state.metricKey]), state.metricKey),
          formatNumber(coerceNumber(row.population), { maximumFractionDigits: 2 }),
          formatNumber(coerceNumber(row.gdp), { maximumFractionDigits: 2 })
        ];
        cells.forEach(cell => {
          const td = document.createElement('td');
          td.textContent = cell;
          tr.appendChild(td);
        });
        elements.previewBody.appendChild(tr);
      });
    }

    function updateQualityChecks() {
      const metricKey = state.metricKey;
      const yearValues = cachedRows.map(row => coerceYear(row.year)).filter(val => val !== null);
      const minYear = yearValues.length ? Math.min(...yearValues) : '—';
      const maxYear = yearValues.length ? Math.max(...yearValues) : '—';

      const duplicateSet = new Set();
      let duplicateCount = 0;
      cachedRows.forEach(row => {
        const iso = cleanValue(row.iso_code) || 'UNKNOWN';
        const year = coerceYear(row.year);
        if (year === null) return;
        const key = `${iso}-${year}`;
        if (duplicateSet.has(key)) {
          duplicateCount += 1;
        } else {
          duplicateSet.add(key);
        }
      });

      const missingIsoCount = cachedRows.reduce((acc, row) => {
        const iso = cleanValue(row.iso_code);
        return acc + (iso ? 0 : 1);
      }, 0);

      let nonNumericCount = 0;
      cachedRows.forEach(row => {
        const raw = row[metricKey];
        const cleaned = cleanValue(raw);
        if (cleaned === null) return;
        const num = Number(cleaned);
        if (!Number.isFinite(num)) nonNumericCount += 1;
      });

      elements.qualityList.innerHTML = '';
      const items = [
        `Detected year range: ${minYear}–${maxYear}`,
        `Duplicate (iso_code, year) rows: ${formatNumber(duplicateCount, { maximumFractionDigits: 0 })}`,
        `Rows missing iso_code: ${formatNumber(missingIsoCount, { maximumFractionDigits: 0 })}`,
        `Rows with non-numeric ${metricKey} values coerced to null: ${formatNumber(nonNumericCount, { maximumFractionDigits: 0 })}`
      ];
      items.forEach(item => {
        const div = document.createElement('div');
        div.className = 'quality-item';
        div.textContent = item;
        elements.qualityList.appendChild(div);
      });
    }

    function downloadFilteredCSV() {
      const filtered = filterRows(cachedRows, { applyCountry: true });
      const rows = filtered.map(row => ({
        country: cleanValue(row.country) || '',
        iso_code: cleanValue(row.iso_code) || '',
        year: coerceYear(row.year) || '',
        [state.metricKey]: coerceNumber(row[state.metricKey]),
        population: coerceNumber(row.population),
        gdp: coerceNumber(row.gdp)
      }));

      const csv = Papa.unparse(rows);
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `coal-eda-${state.metricKey}-${Date.now()}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function destroyChart(canvasId) {
      const existing = Chart.getChart(canvasId);
      if (existing) existing.destroy();
    }

    function renderGlobalTrend() {
      const metricMeta = getMetricMeta(state.metricKey);
      destroyChart('globalTrendChart');

      window.charting.createChartFromCSV({
        canvasId: 'globalTrendChart',
        csvPath: CSV_PATH,
        chartType: 'line',
        enablePerformanceMode: true,
        requiredFields: ['year'],
        dataProcessor: (rows) => {
          const shareMetric = isShareMetric(state.metricKey);
          const bounds = getYearBounds();
          const yearLabels = [];
          for (let year = bounds.start; year <= bounds.end; year += 1) {
            yearLabels.push(year);
          }

          const aggregates = new Map();
          yearLabels.forEach(year => {
            aggregates.set(year, { sum: 0, count: 0, weightedSum: 0, weight: 0, usedWeighted: false, usedMean: false });
          });

          rows.forEach(row => {
            const year = coerceYear(row.year);
            if (year === null || year < bounds.start || year > bounds.end) return;
            const value = coerceNumber(row[state.metricKey]);
            if (value === null) return;
            const entry = aggregates.get(year);
            if (!entry) return;

            if (shareMetric) {
              const pop = coerceNumber(row.population);
              if (pop !== null) {
                entry.weightedSum += value * pop;
                entry.weight += pop;
                entry.usedWeighted = true;
              } else {
                entry.sum += value;
                entry.count += 1;
                entry.usedMean = true;
              }
            } else {
              entry.sum += value;
              entry.count += 1;
            }
          });

          let noteText = '';
          if (shareMetric) {
            const usedWeighted = Array.from(aggregates.values()).some(entry => entry.usedWeighted);
            const usedMean = Array.from(aggregates.values()).some(entry => entry.usedMean);
            if (usedWeighted && usedMean) {
              noteText = 'Population-weighted average where population exists; simple mean for rows without population.';
            } else if (usedWeighted) {
              noteText = 'Population-weighted average based on available population data.';
            } else {
              noteText = 'Simple mean (population data missing in selection).';
            }
          }
          elements.globalTrendNote.textContent = noteText;

          const dataValues = yearLabels.map(year => {
            const entry = aggregates.get(year);
            if (!entry) return null;
            if (shareMetric) {
              if (entry.weight > 0 && entry.count > 0) {
                return (entry.weightedSum + entry.sum) / (entry.weight + entry.count);
              }
              if (entry.weight > 0) return entry.weightedSum / entry.weight;
              if (entry.count > 0) return entry.sum / entry.count;
              return null;
            }
            return entry.count > 0 ? entry.sum : null;
          });

          return {
            labels: yearLabels,
            datasets: [{
              label: `Global ${metricMeta.label}`,
              data: dataValues,
              borderColor: '#0f4c81',
              backgroundColor: 'rgba(15, 76, 129, 0.2)',
              tension: 0.25,
              fill: true,
              pointRadius: 2
            }]
          };
        },
        chartOptions: {
          plugins: {
            legend: { display: true }
          },
          scales: {
            x: { title: { display: true, text: 'Year' } },
            y: { title: { display: true, text: `${metricMeta.label} (${metricMeta.unit})` } }
          }
        }
      });
    }

    function renderCoverage() {
      const metricMeta = getMetricMeta(state.metricKey);
      destroyChart('coverageChart');

      window.charting.createChartFromCSV({
        canvasId: 'coverageChart',
        csvPath: CSV_PATH,
        chartType: 'line',
        enablePerformanceMode: true,
        requiredFields: ['year'],
        dataProcessor: (rows) => {
          const bounds = getYearBounds();
          const yearLabels = [];
          for (let year = bounds.start; year <= bounds.end; year += 1) {
            yearLabels.push(year);
          }
          const sets = new Map();
          yearLabels.forEach(year => sets.set(year, new Set()));

          rows.forEach(row => {
            const year = coerceYear(row.year);
            if (year === null || year < bounds.start || year > bounds.end) return;
            const value = coerceNumber(row[state.metricKey]);
            if (value === null) return;
            const key = getCountryKey(row);
            if (!key) return;
            sets.get(year).add(key);
          });

          const dataValues = yearLabels.map(year => sets.get(year).size);

          return {
            labels: yearLabels,
            datasets: [{
              label: `Countries with ${metricMeta.label}`,
              data: dataValues,
              borderColor: '#2563eb',
              backgroundColor: 'rgba(37, 99, 235, 0.2)',
              tension: 0.25,
              fill: true,
              pointRadius: 2
            }]
          };
        },
        chartOptions: {
          plugins: { legend: { display: false } },
          scales: {
            x: { title: { display: true, text: 'Year' } },
            y: { title: { display: true, text: 'Countries with data' } }
          }
        }
      });
    }

    function renderTopCountries() {
      const metricMeta = getMetricMeta(state.metricKey);
      destroyChart('topCountriesChart');

      window.charting.createChartFromCSV({
        canvasId: 'topCountriesChart',
        csvPath: CSV_PATH,
        chartType: 'bar',
        enablePerformanceMode: true,
        requiredFields: ['year'],
        dataProcessor: (rows) => {
          const bounds = getYearBounds();
          const map = new Map();

          rows.forEach(row => {
            const year = coerceYear(row.year);
            if (year === null || year < bounds.start || year > bounds.end) return;
            const value = coerceNumber(row[state.metricKey]);
            if (value === null) return;
            const key = getCountryKey(row);
            if (!key) return;
            if (!map.has(key)) {
              map.set(key, { label: getCountryLabel(row), sum: 0, count: 0, years: new Set() });
            }
            const entry = map.get(key);
            entry.sum += value;
            entry.count += 1;
            entry.years.add(year);
          });

          const ranked = Array.from(map.values()).map(entry => {
            const value = state.yearMode === 'single' ? entry.sum : entry.sum / entry.count;
            return { label: entry.label, value, years: entry.years.size };
          });

          ranked.sort((a, b) => b.value - a.value);
          const top = ranked.slice(0, 15);

          return {
            labels: top.map(item => item.label),
            datasets: [{
              label: state.yearMode === 'single' ? `${metricMeta.label} (${bounds.start})` : `${metricMeta.label} (avg)`,
              data: top.map(item => item.value),
              backgroundColor: 'rgba(16, 42, 67, 0.7)',
              borderColor: '#102a43',
              borderWidth: 1,
              metaYears: top.map(item => item.years)
            }]
          };
        },
        chartOptions: {
          indexAxis: 'y',
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: (context) => {
                  const raw = context.dataset.data[context.dataIndex];
                  let label = `${context.label}: ${formatNumber(raw, { maximumFractionDigits: 2 })}`;
                  if (state.yearMode === 'range') {
                    const yearsCount = context.dataset.metaYears[context.dataIndex];
                    label += ` (years: ${yearsCount})`;
                  }
                  return label;
                }
              }
            }
          },
          scales: {
            x: { title: { display: true, text: `${metricMeta.label} (${metricMeta.unit})` } },
            y: { ticks: { autoSkip: false } }
          }
        }
      });
    }

    function renderMissingness() {
      destroyChart('missingnessChart');

      window.charting.createChartFromCSV({
        canvasId: 'missingnessChart',
        csvPath: CSV_PATH,
        chartType: 'bar',
        enablePerformanceMode: true,
        requiredFields: ['year'],
        dataProcessor: (rows) => {
          const filtered = filterRows(rows, { applyCountry: true });
          const total = filtered.length || 1;

          const labels = [];
          const values = [];

          KEY_VARIABLES.forEach(key => {
            const missing = filtered.reduce((acc, row) => {
              const value = coerceNumber(row[key]);
              return acc + (value === null ? 1 : 0);
            }, 0);
            labels.push(key);
            values.push((missing / total) * 100);
          });

          return {
            labels,
            datasets: [{
              label: 'Missingness %',
              data: values,
              backgroundColor: 'rgba(220, 38, 38, 0.6)',
              borderColor: '#dc2626',
              borderWidth: 1
            }]
          };
        },
        chartOptions: {
          plugins: { legend: { display: false } },
          scales: {
            x: { ticks: { maxRotation: 60, minRotation: 30 } },
            y: { title: { display: true, text: 'Missingness (%)' }, min: 0, max: 100 }
          }
        }
      });
    }

    function renderCountryProfile() {
      if (!state.selectedCountry) {
        elements.countryProfileSection.classList.add('hidden');
        destroyChart('countryProfileChart');
        return;
      }

      elements.countryProfileSection.classList.remove('hidden');
      destroyChart('countryProfileChart');

      const metricMeta = getMetricMeta(state.metricKey);
      window.charting.createChartFromCSV({
        canvasId: 'countryProfileChart',
        csvPath: CSV_PATH,
        chartType: 'line',
        enablePerformanceMode: true,
        requiredFields: ['year'],
        dataProcessor: (rows) => {
          const filtered = applyCountryFilter(rows).filter(row => {
            const year = coerceYear(row.year);
            return inYearRange(year);
          });

          const bounds = getYearBounds();
          const yearLabels = [];
          for (let year = bounds.start; year <= bounds.end; year += 1) {
            yearLabels.push(year);
          }

          const mainMap = new Map();
          const compareMap = new Map();
          filtered.forEach(row => {
            const year = coerceYear(row.year);
            if (year === null) return;
            const value = coerceNumber(row[state.metricKey]);
            if (value !== null) mainMap.set(year, value);

            if (state.metricKey === 'coal_electricity') {
              const fossil = coerceNumber(row.fossil_electricity);
              if (fossil !== null) compareMap.set(year, fossil);
            }
            if (state.metricKey === 'coal_share_elec') {
              const fossilShare = coerceNumber(row.fossil_share_elec);
              if (fossilShare !== null) compareMap.set(year, fossilShare);
            }
          });

          const datasets = [{
            label: metricMeta.label,
            data: yearLabels.map(year => mainMap.has(year) ? mainMap.get(year) : null),
            borderColor: '#0f4c81',
            backgroundColor: 'rgba(15, 76, 129, 0.2)',
            tension: 0.25,
            fill: false,
            pointRadius: 2
          }];

          if (compareMap.size > 0) {
            const compareLabel = state.metricKey === 'coal_electricity' ? 'Fossil electricity' : 'Fossil share of electricity';
            datasets.push({
              label: compareLabel,
              data: yearLabels.map(year => compareMap.has(year) ? compareMap.get(year) : null),
              borderColor: '#f59e0b',
              backgroundColor: 'rgba(245, 158, 11, 0.2)',
              borderDash: [6, 4],
              tension: 0.25,
              fill: false,
              pointRadius: 2
            });
          }

          return {
            labels: yearLabels,
            datasets
          };
        },
        chartOptions: {
          plugins: { legend: { display: true } },
          scales: {
            x: { title: { display: true, text: 'Year' } },
            y: { title: { display: true, text: `${metricMeta.label} (${metricMeta.unit})` } }
          }
        }
      });
    }

    function renderCharts() {
      renderGlobalTrend();
      renderCoverage();
      renderTopCountries();
      renderMissingness();
      renderCountryProfile();
    }

    function updateAll() {
      if (!cachedRows.length) return;
      updateKPIs();
      updatePreviewTable();
      updateQualityChecks();
      renderCharts();
    }

    function handleMetricChange() {
      state.metricKey = elements.metricSelect.value;
      updateAll();
    }

    function handleYearModeChange(mode) {
      state.yearMode = mode;
      updateToggleButtons();
      updateAll();
    }

    function handleYearChange() {
      state.year = parseInt(elements.singleYearSelect.value, 10);
      state.startYear = parseInt(elements.startYearSelect.value, 10);
      state.endYear = parseInt(elements.endYearSelect.value, 10);

      if (state.startYear > state.endYear) {
        const tmp = state.startYear;
        state.startYear = state.endYear;
        state.endYear = tmp;
        elements.startYearSelect.value = state.startYear;
        elements.endYearSelect.value = state.endYear;
      }
      updateAll();
    }

    function handleCountryChange() {
      const resolved = resolveCountry(elements.countryInput.value);
      state.selectedCountry = resolved ? { country: resolved.country, iso: resolved.iso } : null;
      state.selectedCountryDisplay = resolved ? resolved.display : '';
      updateAll();
    }

    function initListeners() {
      elements.metricSelect.addEventListener('change', handleMetricChange);
      elements.singleYearSelect.addEventListener('change', handleYearChange);
      elements.startYearSelect.addEventListener('change', handleYearChange);
      elements.endYearSelect.addEventListener('change', handleYearChange);
      elements.countryInput.addEventListener('change', handleCountryChange);
      elements.countryInput.addEventListener('blur', handleCountryChange);
      elements.downloadBtn.addEventListener('click', downloadFilteredCSV);

      document.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.addEventListener('click', () => handleYearModeChange(btn.dataset.mode));
      });
    }

    function showParseError(message) {
      elements.parseError.textContent = `CSV parse failed for ${CSV_PATH}: ${message}`;
      elements.parseError.classList.remove('hidden');
    }

    function parseCSV() {
      Papa.parse(CSV_PATH, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          if (results.errors && results.errors.length) {
            showParseError(results.errors[0].message);
            return;
          }

          cachedRows = results.data || [];
          const yearSet = new Set();
          const countryMap = new Map();

          cachedRows.forEach(row => {
            const year = coerceYear(row.year);
            if (year !== null) yearSet.add(year);

            const country = cleanValue(row.country);
            const iso = cleanValue(row.iso_code);
            if (country) {
              const display = iso ? `${country} (${iso})` : country;
              if (!countryMap.has(display)) {
                countryMap.set(display, { display, country, iso });
              }
            }
          });

          yearsList = Array.from(yearSet).sort((a, b) => a - b);
          countryIndex = countryMap;

          setMetricOptions();
          setYearOptions();
          setCountryOptions();
          updateToggleButtons();
          initListeners();
          updateAll();
        },
        error: (error) => {
          showParseError(error.message || 'Unknown error');
        }
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      parseCSV();
    });
  </script>
</body>
</html>
